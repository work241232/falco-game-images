name: Batch Download Game Images

on:
  issues:
    types: [opened, labeled]
  workflow_dispatch:
    inputs:
      process_all_pending:
        description: 'Process all pending image requests'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'

jobs:
  # Job per identificare le issue da processare
  identify-issues:
    runs-on: ubuntu-latest
    outputs:
      issue_ids: ${{ steps.find-issues.outputs.issue_ids }}
      has_issues: ${{ steps.find-issues.outputs.has_issues }}
    steps:
      - name: Find pending image requests
        id: find-issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Cerca tutte le issue aperte con etichetta 'image-request' ma senza 'completed'
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'image-request',
            });
            
            // Filtra le issue che non hanno 'completed' come etichetta
            const pendingIssues = issues.data.filter(issue => 
              !issue.labels.some(label => label.name === 'completed')
            );
            
            console.log(`Found ${pendingIssues.length} pending image requests`);
            
            // Se nessuna issue è in attesa, termina
            if (pendingIssues.length === 0) {
              console.log('No pending image requests to process');
              core.setOutput('has_issues', 'false');
              core.setOutput('issue_ids', '[]');
              return;
            }
            
            // Ottieni gli ID delle issue in attesa
            const issueIds = pendingIssues.map(issue => issue.number);
            console.log('Pending issue IDs:', issueIds);
            
            core.setOutput('has_issues', 'true');
            core.setOutput('issue_ids', JSON.stringify(issueIds));

  # Job principale che gestisce il download in sequenza
  process-image-queue:
    needs: identify-issues
    if: needs.identify-issues.outputs.has_issues == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Utilizza fetch-depth: 0 per ottenere l'intera storia del repository
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action Bot"
          git config pull.rebase false  # Usa merge per risolvere conflitti

      - name: Process image requests sequentially
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issues = JSON.parse('${{ needs.identify-issues.outputs.issue_ids }}');
            console.log(`Processing ${issues.length} image requests in sequence`);
            
            // Crea directory images se non esiste
            const fs = require('fs');
            if (!fs.existsSync('./images')) {
              fs.mkdirSync('./images');
            }
            
            // Processa ogni issue in sequenza
            for (const issueId of issues) {
              try {
                console.log(`\n------------------------------`);
                console.log(`Processing issue #${issueId}`);
                
                // Ottieni i dettagli dell'issue
                const issue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueId
                });
                
                console.log(`Issue title: ${issue.data.title}`);
                
                // Estrai informazioni dall'issue body
                const body = issue.data.body || '';
                
                // Estrai URL dell'immagine
                const imageUrlMatch = body.match(/Image URL:\s*(https?:\/\/[^\s]+)/);
                if (!imageUrlMatch) {
                  console.log(`No image URL found in issue #${issueId}`);
                  await addCommentAndLabel(issueId, '❌ Failed to extract image URL from issue body', ['needs-manual-intervention']);
                  continue;
                }
                const imageUrl = imageUrlMatch[1].trim();
                
                // Estrai nome file target
                let targetFilename = '';
                const filenameMatch = body.match(/Target filename:\s*`([^`]+)`/);
                if (filenameMatch) {
                  targetFilename = filenameMatch[1].trim();
                } else {
                  // Estrai nome del gioco
                  const gameMatch = body.match(/Game:\s*(.+?)(?:$|\n)/);
                  if (!gameMatch) {
                    console.log(`No game name or target filename found in issue #${issueId}`);
                    await addCommentAndLabel(issueId, '❌ Failed to extract game name or target filename from issue body', ['needs-manual-intervention']);
                    continue;
                  }
                  
                  // Genera nome file dal nome del gioco
                  const gameName = gameMatch[1].trim();
                  targetFilename = gameName.toLowerCase().replace(/[^a-z0-9._-]/gi, '_').replace(/_+/g, '_');
                  
                  // Estrai publisher se disponibile
                  const publisherMatch = body.match(/Publisher:\s*(.+?)(?:$|\n)/);
                  if (publisherMatch) {
                    const publisher = publisherMatch[1].trim();
                    const sanitizedPublisher = publisher.toLowerCase().replace(/[^a-z0-9._-]/gi, '_').replace(/_+/g, '_');
                    targetFilename = `${targetFilename}_${sanitizedPublisher}`;
                  }
                  
                  // Aggiungi estensione
                  if (!targetFilename.match(/\.(jpg|jpeg|png|webp|gif)$/i)) {
                    targetFilename += '.jpg';
                  }
                }
                
                // Sanitizza il nome del file target per sicurezza
                const sanitizedFilename = targetFilename.toLowerCase()
                  .replace(/[^a-z0-9._-]/gi, '_')
                  .replace(/_+/g, '_');
                
                console.log(`Image URL: ${imageUrl}`);
                console.log(`Target filename: ${sanitizedFilename}`);
                
                // Percorso completo del file
                const filePath = `images/${sanitizedFilename}`;
                
                // Fai un pull prima di qualsiasi modifica
                await exec.exec('git', ['pull', '--no-rebase']);
                
                // Scarica l'immagine
                console.log(`Downloading image to ${filePath}...`);
                await exec.exec('curl', ['-L', '-o', filePath, imageUrl]);
                
                // Verifica se il file è stato scaricato
                if (!fs.existsSync(filePath)) {
                  console.log(`Download failed for issue #${issueId}`);
                  await addCommentAndLabel(issueId, '❌ Failed to download image', ['needs-manual-intervention']);
                  continue;
                }
                
                // Verifica se il file è davvero un'immagine
                const fileStats = fs.statSync(filePath);
                if (fileStats.size < 100) {
                  console.log(`Downloaded file appears to be too small (${fileStats.size} bytes)`);
                  await addCommentAndLabel(issueId, '❌ Downloaded file appears to be too small or not a valid image', ['needs-manual-intervention']);
                  continue;
                }
                
                // Aggiungi e committa il file
                await exec.exec('git', ['add', filePath]);
                
                // Verifica se ci sono modifiche da committare
                const { exitCode } = await exec.getExecOutput('git', ['diff', '--staged', '--quiet'], { ignoreReturnCode: true });
                if (exitCode === 0) {
                  console.log('No changes to commit, file may already exist with same content');
                  await addCommentAndLabel(issueId, '✅ Image with identical content was already present in the repository', ['completed', 'automated']);
                  continue;
                }
                
                // Ottieni il nome del gioco dall'issue title o dal body
                let gameName = issue.data.title.replace(/^Download image for: /i, '').trim();
                const gameNameMatch = body.match(/Game:\s*(.+?)(?:$|\n)/);
                if (gameNameMatch) {
                  gameName = gameNameMatch[1].trim();
                }
                
                // Fai commit
                await exec.exec('git', ['commit', '-m', `Add image: ${sanitizedFilename} (from issue #${issueId})`]);
                
                // Pull nuovamente in caso di modifiche nel frattempo
                await exec.exec('git', ['pull', '--no-rebase']);
                
                // Push
                console.log('Pushing changes...');
                await exec.exec('git', ['push']);
                
                // Commenta sull'issue e chiudila
                console.log(`Successfully processed issue #${issueId}`);
                await addCommentAndLabel(issueId, `✅ Image has been automatically downloaded and added to the repository as \`${filePath}\`.`, ['automated', 'completed']);
                
                // Chiudi l'issue
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueId,
                  state: 'closed'
                });
                
              } catch (error) {
                console.error(`Error processing issue #${issueId}:`, error);
                await addCommentAndLabel(issueId, `❌ Failed to process image request: ${error.message}`, ['needs-manual-intervention']);
              }
            }
            
            // Funzione helper per aggiungere commento ed etichette
            async function addCommentAndLabel(issueId, commentText, labels) {
              // Aggiungi etichette
              if (labels && labels.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueId,
                  labels: labels
                });
              }
              
              // Aggiungi commento
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueId,
                body: commentText
              });
            }